// addEventListener
const btn1 = document.querySelector('.btn1')
btn1.addEventListener('click', () => {
    alert('You clicked me!');
})

const btn2 = document.querySelector('.btn2')
btn2.addEventListener('mouseover', () => {
    btn2.classList.toggle('green')    
})
btn2.addEventListener('mouseout', () => {
    btn2.classList.toggle('green')    
})

const btn3 = document.querySelector('.btn3')
btn3.addEventListener('click', () => {
    let r = Math.floor(Math.random()*255)+1
    let g = Math.floor(Math.random()*255)+1
    let b = Math.floor(Math.random()*255)+1
    let color = `rgb(${r},${g},${b})`
    document.body.style.backgroundColor = color
    
})

// 'this' keyword: Inside of a event handler callback function, the keyword 'this' is going to refer to whatever that event was occured on.
function randomColor(){
    let r = Math.floor(Math.random()*255)+1
    let g = Math.floor(Math.random()*255)+1
    let b = Math.floor(Math.random()*255)+1
    return `rgb(${r},${g},${b})`
}
// Without 'this'
const withoutthis1 = document.querySelector('.withoutthis1')
const withoutthis2 = document.querySelector('.withoutthis2')
withoutthis1.addEventListener('click', () => {
    withoutthis1.style.backgroundColor = randomColor()
})
withoutthis2.addEventListener('click', () => {
    withoutthis2.style.backgroundColor = randomColor()
})
// Demonstrating 'this'
const demonstratingthis1 = document.querySelector('.demonstratingthis1')
const demonstratingthis2 = document.querySelector('.demonstratingthis2')
demonstratingthis1.addEventListener('click', colorize)
demonstratingthis2.addEventListener('click', colorize)
function colorize(){ 
    this.style.backgroundColor = randomColor()
}

// Event object: It is automatically passed in the event handler callback function. We can capture it by putting in an parameter. It contains information about the event
const btn4 = document.querySelector('.btn4')
btn4.addEventListener('mouseover', (evt) => {
    btn4.classList.toggle('green')
        // console.log(evt)
})
// Keyboard event: We can use keydown or keyup event, but to find which key was pressed we need to use event object. 
const keyboardevent = document.querySelector('.keyboardevent')
keyboardevent.addEventListener('keydown', (evt) => {
    // code returns information about the physical key that was pressed, key contains the character that is generated by that key
        // console.log(evt.key)
        // console.log(evt.code)
})
// global keyboard event
window.addEventListener('keydown', (evt) => {
    // code returns information about the physical key that was pressed, key contains the character that is generated by that key
        // console.log(evt.key)
        // console.log(evt.code)
})

// Form events
// By default when we press submit in a form, it takes us to a different URL. To prevent that from happening we have to use event.preventdefault()
const form = document.querySelector('.form')
form.addEventListener('submit', (evt) => {
    evt.preventDefault()
    console.log('Submitted the form')
    // Extracting data from the form
    const input = document.querySelector('.input')
    console.log(input.value)
    input.value = "" // to clear the form
})

// change event: Works when you change something in the form and then leave the area
const changeevent = document.querySelector('.changeevent')
changeevent.addEventListener('change', (evt) => {
    const h2a = document.querySelector('.h2a')
    const input2 = document.querySelector('.input2')
    h2a.innerText = input2.value
})
// input event
const inputevent = document.querySelector('.inputevent')
inputevent.addEventListener('input', (evt) => {
    const h2b = document.querySelector('.h2b')
    const input3 = document.querySelector('.input3')
    h2b.innerText = input3.value
})

// Event bubbling: What this means is that when an event occurs then all the events of its parents also occur i.e. the event bubbles up
const eventbubble = document.querySelector('.eventbubble')
const eventbubblebutton = document.querySelector('.eventbubblebutton')
eventbubble.addEventListener('click', () => {
    eventbubble.style.display = 'none'
})
eventbubblebutton.addEventListener('click', (evt) => {
    console.log('I am printed')
    // The problem we run into is that when the eventbubblebutton event is triggered, then eventbubble event also gets triggered. To prevent that from happening we have to use event.stopPropagation()
    evt.stopPropagation()
})

// Event delegation
const form2 = document.querySelector('.form2')
const eventdelegation = document.querySelector('.eventdelegation')
const ul = document.querySelector('ul')
form2.addEventListener('submit', (evt) => {
    evt.preventDefault()
    const li = document.createElement('li')
    li.append(`${eventdelegation.value}`)
    ul.append(li)
    eventdelegation.value=""
})
const lis = document.querySelectorAll('li')
for(let li of lis){
    li.addEventListener('click', () => {
        li.style.display = 'none'
    })
}
// We notice that we are only able to remove the OG li's not the ones that we inserted through javascript, this is because li.addEventListener has no idea of any new li's that may be added after the script was executed. So that event listener is only applicable for the OG li's. To solve this problem we can use something called event delegation. Event delegation refers to the process handling events at a higher level in the DOM than the element on which the event originated. It allows us to attach a single event listener to parent element for its child elements that exist now or in the future.
const form3 = document.querySelector('.form3')
const eventdelegation2 = document.querySelector('.eventdelegation2')
const ul2 = document.querySelector('.ul2')
form3.addEventListener('submit', (evt) => {
    evt.preventDefault()
    const li = document.createElement('li')
    li.append(`${eventdelegation2.value}`)
    ul2.append(li)
    eventdelegation2.value=""
})
const lis2 = document.querySelectorAll('li')
ul2.addEventListener('click', (evt) => {
    // We will use the event.target property to find the child element that was clicked on.
    if(evt.target.nodeName === 'LI')
        evt.target.style.display = 'none'

})